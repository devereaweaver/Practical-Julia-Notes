### A Pluto.jl notebook ###
# v0.19.9

using Markdown
using InteractiveUtils

# ╔═╡ 2c2fd9f4-6d24-11ed-3117-23d7346a8f33
md"""
# 5.Collections

## Controlling Loop Execution; Comprehensions and Generators

This section covers how more statements useful in our looping structures as well as writing compact loops using comprehensions. 

### Terminating Loops with *break*

Like many other languages, Julia has a *break* statement that can be used to end both while and for loops.
"""

# ╔═╡ cd53e3c6-5a08-40f6-a3a8-ae37f70f43af
# ERROR: Pluto doesn't work with reading from stdin,
# running this code in the browser will cause issues
begin
	while true
		println("Enter a number, or 0 to quit.")
		x = readline()
		x = parse(Float64, x)    # parse string as 64-bit integer
		if x ≤ 0    # the only exit condition
			break
		end
		println("The square root is ", sqrt(x))
	end
end

# ╔═╡ 40dc108b-f8e8-41c3-9fbe-afa1137a5bba
begin
	n = [12, 53, 19, 64, 16, 8]
	
	for x in n
		if round(√x) == √x
			println("Found a perfect square in the list: ", x)
			break
		end
	end
end

# ╔═╡ d2b0d0d1-5fce-4ed8-b922-d5c40595ebaf
# continue 
begin

for n in 1:100
	possibly_prime = true
	x = 2
	while x < √n
		if n % x == 0    # x divides n evenly
			possibly_prime = false
			break
		end
		x += 1
	end
	if !possibly_prime    
		continue
	else
		println(n)
	end
end

end

# ╔═╡ e8498f77-296b-4587-8cdd-7dac92c5a7af
md"""
### Creating Loops with Comprehensions

Let's check out two ways to create arrays using looping structures. We want to create a vector containing the first five perfect squares. Our first example constructs this using a standard for loop and the second creates the array using an *array comprehension*. 

Observe,
"""

# ╔═╡ 193d7648-fdf5-4254-8d70-34f32b6620b6
begin
	# using a for loop
	xs = []    # empty vector 
	for x in 1:5
		push!(xs, x^2)    # add square to empty vector
	end
	xs

	# using an array comprehension
	xs = [x^2 for x in 1:5]
	xs
end 

# ╔═╡ 85f8f1cc-004e-4f4c-bdbd-50dbeeb68b2e
md"""
Using an array comprehension allows use to compacting generate an array of values in one line. There is no need to initialize an empty array first and then loop over it to fill its indices. Creation of the array and population both occur in the same step. 

The first part of the array comprehension is the implied loop and the second part is the for loop syntax that determines how many iterations will occur. 

Observe the following, the array that is created using an array comprehension will take on the same shape as the container used in the second part. 
"""

# ╔═╡ b043f043-92f5-4caf-b382-68cbee016731
# double the elements a matrix using comprehension
[2x for x in [1 2
					3 4]]

# ╔═╡ 4e3851a1-83ef-4e83-aaa0-3ea76489ba19
# multiple implied loops (creates vector)
[x * y for x in 1:3 for y in 1:3]

# ╔═╡ 399a16b6-7cae-4d7d-8715-3e0d34c291ff
# creates matrix since we are using a ;
[x * y for x in 1:3, y in 1:3]

# ╔═╡ fa9aa79a-9c9d-4bd0-9991-af5b72f5088d
md"""
**NOTE:** For what I intend on doing, being able to generate matrices like this may end up being very useful. 

### Generator Expressions 

These create an iterator rather than a populated array. We can iterate over this object to use its members one at a time while it occupies almost no memory. 
"""

# ╔═╡ 0a08e119-95ba-4b75-99f7-17af4fcb298e
# use a generator to build a multiplication table
multiplication_generator = (x * y for x in 1:9, y in 1:9)

# ╔═╡ ba8a0fc3-795c-4465-a51e-5efaae00687d
[n for n in multiplication_generator
 if n%2 == 0 && n%7 ==0] |> unique

# ╔═╡ fe27b89d-40e2-47bb-88b2-2b14ff4790ae
# to see the values of our generator, use collect()
collect(multiplication_generator)

# ╔═╡ 6b5516d0-e97c-4acd-a652-4d8732bc78f5
md"""
For clarification purposes, a generator is used to generate a sequence or set of objects (numbers, strings, etc.) without having to store their values in data structure in memory. The values are generated when asked for and they aren't typically all stored in memory.  This reduces the memory footprint of the computation but still allows for the values.

However, one this to note is that there doesn't appear to be any way to really traverse the sequence generated by a generator since it doesn't store the sequence in memory. You simply get the values, meaning you can't go backward and select specific elements. This is the tradeoff and there are some use cases when this would be better to use than taking up memory.
"""

# ╔═╡ bc0032ee-a126-41bd-9372-37816383b6ca
md"""
## More Ways to Join Strings 

Julia's *string()* function joins any number of literal strings and string-valued variables into a larger String object.
"""

# ╔═╡ 1024a5dd-716d-453b-80b8-b2b00d324d42
# string literal
comma_space = ", ";

# ╔═╡ 801e5484-eb2e-4a26-88d2-7142a3d0b4e7
# create a String object using the previous string literal and string() function 
string("Hello", comma_space, "François!")

# ╔═╡ 734bf1af-7a23-427d-a60d-c5556e52ca6a
# string() converts objects to their string representation if possible
string("I am ", 30, " years old.")

# ╔═╡ 5b574b39-685a-4447-96cb-f7c4bc930743
# repeat() joins a string to itself a specified number of times 
repeat("ABC ", 5)

# ╔═╡ 2861dd72-fcf8-4e02-a482-50c180a61166
md"""
## Nonstandard String Literals

Julia supports nonstandard string literals by specifying a keyword in front of the string literal whic defines the special-purpose string the expresssion represents. 
Some examples include LaTeX, raw strings, and byte array literals. 

### Raw STrings 

Raw strings are used to represent certain character sequences literally. 
"""

# ╔═╡ a53cd5d1-c7b4-4abf-bc07-59f18926c8f8
# interpret \t literally instead of at TAB
print(raw"a\tb")

# ╔═╡ 7138bdba-2574-4195-bb5b-9d576b55a8b4
print("a\tb")

# ╔═╡ 17482ccc-3b7d-4e0d-a3a8-f82c8709014a
md"""
So backslashes are still needed to escape double quotation marks in raw strings. 

### Semantic Version Strings 

Semantic version strings are used to define versions of software releases. Their fields are major and minor versions along with optionally adding other versioning information. When we use this as a type of string, we can access these fields.
"""

# ╔═╡ 8f617661-d7b0-4704-b05c-b9e6ff002c98
# compare versions
v"1.6.1" < v"1.6.2"

# ╔═╡ 1669072b-f907-44c3-b0e8-747e7e3b2933
version = v"1.7.2"

# ╔═╡ ad458e5b-b795-4e6f-a1a0-dfbc933efdad
version.major, version.minor, version.patch

# ╔═╡ 60218ddd-1cf2-4ddb-bfbe-92ae25cd556b
md"""
I'm sure this has some use case somewhere but I'm not sure right now. 

### String Searching and Replacing 

Use the *replace()* function to replace a substring with a different one. 

Note: It doesn't appear to alter the actual string object.
"""

# ╔═╡ 1f3f9255-d98a-4fcc-b789-29064a3e98f2
s = "abc";

# ╔═╡ d6eca711-c152-4606-92dc-b62320cb7954
replace(s, "b" => "XX", "c" => "Z")

# ╔═╡ 9541ab93-12e7-4f11-b310-4246d962f23f
s

# ╔═╡ 7d408506-d311-4be5-893a-42a63baec349
# Z in the first replacement is not replaced by WWW, kind of weird
replace(s, "c" => "Z", "Z" => "WWW")

# ╔═╡ b119dbae-d64c-4c0e-884f-b2e55e30d387
# test for presence of a substring in a string 
occursin("abc", "abcdef")

# ╔═╡ 71ef4dc2-1cae-4afc-945a-379a79b70439
occursin("abc", "abCdef")

# ╔═╡ 3eeeb46c-5808-42d8-bd10-a9461050085d
# return index of where char or string occur in a String
findfirst('a', "abcabc")

# ╔═╡ fbb5fbcc-b602-4404-a98a-84d0dbac92f0
findlast('a', "abcabc")

# ╔═╡ 1be8dd97-8aa7-4145-8d35-adc373246dc0
# return locations of substring in string
findfirst("abc", "abcabc")

# ╔═╡ ba48907a-e0fb-468e-b8a4-fe8638f42bb7
findlast("abc", "abcabc")

# ╔═╡ 6f68f0dd-dde1-4bd3-8153-88d395495b3a
# character doesn't exist in string (returns nothing)
findfirst('z', "abcabc")

# ╔═╡ 6a944825-1594-40fb-ba2b-adde7159a560
# find next  
begin
	q = "To be or not to be, that is the question"
	i = 0   # counter to iterate over string
	locations = []    # store locations of character

	# nothing is returned by findnext() when there are no more instances to 
	# be found in the string, in other words, there are no more 'e's to be found
	while i != nothing  
		global i = findnext('e', q, i+1)    # look for 'e' in q incrementing location
		push!(locations, i)    # add locations of e to array (locations = i)
	end

	print("""The letter "e" was found at locations """,
	join(locations[1:end-1], ", ", " and "), ".")
end

# ╔═╡ 992daf44-151d-4325-bfcd-2cf34f84a89c
md"""
**NOTE:** In the above code chunk, we had to mark 'i' as *global* since we are redefining it there and Pluto doesn't like redefining names. In a normal program however, this would be ok to do. 

Also object in the *join()* function, we added an optional third argument that is to take the place of the delimiter between the final two elements. This is nice as I don't have to write out a test for the final element and print a different delimiter as I have to do in some other languages. 

There's much more to String types; however, dive into the docs and other resources as needed when working with strings. For my anticipated work, collections containing numerical objects should be the main focus for now. With that said, let's move on to other types of collections. 

## Additional Collection Types 

### Dictionaries 

The *Dict* type is basically the same thing as a Python dictionary. It consists of a sect of key-value pairs and the values are indexed by the corresponding key.

"""

# ╔═╡ b7d775e0-5dcb-4a14-b068-8e2d5c2c080a
bd = Dict("one"=>1, "two"=>2)

# ╔═╡ 9e6ab062-6a0e-4dea-b406-5e6b1257f93e
md"""
I will say though, I like the syntax of this better than using the : in Python. This reminds me more of a mapping which is basically what the key-value pairs represent. Dictionaries can also be initialized with an iterable object. We also do not have to have the keys and values be all of the same type. 

For example, above both keys are strings and both values are integers. 
"""

# ╔═╡ 2fc33a9f-28f1-4e9a-88d7-a161a435cb00
# index a dictionary  using the keys
bd["one"]

# ╔═╡ 6f479153-fe99-4d53-9afa-d71add3e24f3
# return a list of the keys 
keys(bd)

# ╔═╡ 902f03f1-c652-4dc0-adef-ca312216435b
# return a list of the values 
values(bd)

# ╔═╡ 12efc098-5503-4a69-80ac-b0c1b1d1c2f0
md"""
Keep in mind that keys must be unique since they are what is used to index the values in the data structure. Redefining a key will replace the current key. 
"""

# ╔═╡ 0211d068-72ec-4ca0-b118-55939fea2611
# initialize a dictionary uisng Dict() an dan iterable 
Dict([("one", 1), ("two",2)])

# ╔═╡ 5001c3ee-bdb2-460a-b4a1-6ad61cbe0f7e
md"""
### Sets

An implementation of mathematical sets. They contain the same basic properties of sets.
"""

# ╔═╡ 812c87cf-676d-4798-8107-be84ca7f4cd2
s1 = Set(1:5)

# ╔═╡ db8143be-90b1-4b82-8481-1973c353ca09
s2 = Set(4:8)

# ╔═╡ b3d521e5-51e7-4e1c-84e7-8362a5970bce
# compute intersection 
intersect(s1, s2)

# ╔═╡ 6aa2649a-1093-4266-9f42-8fe576b00a05
# computer union
union(s1, s2)

# ╔═╡ f00ccf5f-9d2c-43ae-bff0-d5b9094ef7c2
# test for subsets
issubset(4:7, s2)

# ╔═╡ 03226d85-57ca-4ca3-9ab1-b6691e90b12b
# subset using symbolic notation 
4:7 ⊆ s2

# ╔═╡ b14aca39-a3e1-486a-a238-5b682620c18b
4:7 ⊇ s2

# ╔═╡ e04c93de-fdf2-44b3-8420-b792d1fe95f3
# set difference
setdiff(s1, 3:5)

# ╔═╡ 1a266b38-d769-453d-8c0f-fe4101e2c892
# add elements to a set
push!(s1, 999);

# ╔═╡ dc1bcc70-ec19-42a5-938c-7837e5d13911
setdiff!(s1, 1:3)

# ╔═╡ 5dfc8e81-b90f-46bd-88ac-d0fcf2b7c1cc
# observe the mutating form of setdiff!() will remove elements 
s1

# ╔═╡ 1dedd305-5f2d-4b52-9ae3-4b47f7d64214
md"""
Keep in mind that there exists mutating forms of many functions, be aware of which one gets called.

### Structs

Recall a struct is a collection of named values packaged together under on identifier. In other words, our struct containts fields with values just like in other programming languages.
"""

# ╔═╡ dac2ae13-bdca-402d-aa58-53fb25c7c383
# observe that by default, we don't need to assign types to the fields since
# Julia is a dynamically typed languge, but we should look into the optional 
# typing later one to enforce it when we need to
struct Website
	url
	title
end

# ╔═╡ 0351ff00-e1d5-4eca-9049-3f1919207fa1
# create instance of struct
google = Website("https://google.com", "google")

# ╔═╡ 171b3c5b-eb59-40b6-a2c5-3eabbd71335c
# use property notation to access fields of composite objects (tuples, structs, etc.)
google.title

# ╔═╡ 9a4f9f42-2328-4b25-90cb-c2047ed7b0c8
# ERROR
google.title = "Google"

# ╔═╡ 1f035d70-ebd0-4c7a-b4ab-af7ce5e055ad
md"""
Observe the error above. By default, structs are immutable and attempts to change the values of their fields won't work . If we plan on routinely mutating structs, then we need to define them as mutable structs. 
"""

# ╔═╡ 1fa9d73f-2866-44a0-8256-4c592efe6998
mutable struct MutableWebsite
	url
	title
end

# ╔═╡ 9468c128-fd0f-4439-b6b3-6644e8e838d2
google2 = MutableWebsite("https://google.com", "google")

# ╔═╡ 2d6fc98b-8585-4734-a6bd-aad91fac5015
google2.title

# ╔═╡ 5d8755bc-9f71-4ca9-b39c-768cc7f42d19
# now we can mutate it
google2.title = "Google"

# ╔═╡ f5471a60-a439-4ee1-91c6-6746d84fc499
md"""
These will likely be used often so modelling with them should become natural. 

### Name Tuples

Basically the same things as a tuple, just that we can give our values in the tuple names that we can use to reference them by using the property notation. Of course, like tuples, named tuples are immutable. 
"""

# ╔═╡ a4f4353f-eb1e-41fb-878a-b0a37288e73e
nt = (a=1, b=2, c=3);

# ╔═╡ dffad748-ca3d-4fde-ad69-e788e7171125
nt.c

# ╔═╡ 1d6d908f-7a2f-4511-93d3-d13a81937d2b
md"""
## More Ways to Initialize Arrays 

Learn these as array-based programming will be my bread and butter moving forward. These methods are often more convenient that using literal array definitions to initialize. 

### repeat 

Repeats an array a given number of times along each axis
"""

# ╔═╡ 8bdad294-0ddf-4ada-b5c9-bc897a598d12
# use repeat to generate a 4x9 matrix
repeat(['a' 'b' '|'], 4, 3)

# ╔═╡ dcdc6fdb-e6d5-4c5c-aaea-3862456d04d4
md"""
In the above example, we take a 1D vector and replicate its elements using 4 rows and 3 column to create a 4x9 matrix. 

### fill 

Takes the value supplied in the first argument and creates an array with a shape given by its subsequent arguments. 
"""

# ╔═╡ 5efc93bd-1522-419b-9fb9-28deee71e206
XY = fill(['X' 'Y'], 3, 4)

# ╔═╡ ec124550-e007-4ebf-b47e-44617d4e8b3b
md"""
### zeros and ones 

Like in other array-based programming languages the functions *zeros()* and *ones()* are special cases of fill that will create matrices with either zeros or ones given the desired matrix shape. 
"""

# ╔═╡ 24e00439-638b-42d0-958c-89d4b3fb9819
# for example
zeros(4,5)

# ╔═╡ a2be4b47-9094-4cb1-b1c9-3d270cd77a65
md"""
The can be a useful technique when initializing an array of floating-point numbers that is going to be populated by direct indexing. It's faster than using push!() since push!() will resize the array as needed since the compiler doesn't know its size beforehand. This means the compiler will have to keep reallocating memory for the array as new elements are added.

If we use these to initialize an array and then fill it, the compiler knows before hand how much memory to allocate and the array will simply just need to be filled with new values. This *can* be more efficient when the size of the array will be known.

### reshape

Transforms an array into a new shape. 
"""

# ╔═╡ 47dbec4d-afcf-4ebb-92bd-57f2ee41b769
# create a 1x6 vector
a1 =  collect(1:6)

# ╔═╡ 271d04ab-98c9-4807-b17c-c531d4a624f1
# change to 3x2 matrix
a2 = reshape(a1, (3,2))

# ╔═╡ 63ed32e4-1823-4138-94ed-25235875af85
md"""
## Array Manipulations Useful in Numerical Algorithms

**This is that sh!t!!**

### General Concatenation

Recall a semicolon is used as a concatenation operator.
"""

# ╔═╡ 2e6209e7-6484-4f8a-8f6b-429fde2c53d3
# concatenating 2 matrices to create 2x2 matrix
m = [[1 2]; [3 4]]

# ╔═╡ 1fd7d2a9-cc72-41f0-bacd-61f151a15b01
# can also use 
m2 = [[1 2
	  3 4]]

# ╔═╡ c3802f33-0a5c-4394-b7d6-11f43b634731
# concatenate along the second dimension to create a single row vector
m3 = [[1 2] ;; [3 4]]

# ╔═╡ 188e6f52-d694-4aee-8239-0a9d89f44570
md"""
This type of concatenation can be extended to a higher number of dimensions, although the representation can be ugly. 

### Logical Indexing 

A BitArray data type allows for Julia to store an array of Boolen values. This also comes in BitVector and BitMatrix flavors. These data type store 0s and 1s to represent a vector of Boolean values. They can be used as logical arrays to act as filters. However, to use a BitArray for logical indexing, it must be the same size as the array that is being indexed. 
"""

# ╔═╡ 181299c9-8898-4b9a-ac41-213551edccb6
# use logical indexing to determine which values in 1...9 are divisible by 3
s3 = (1:9) .% 3 .== 0

# ╔═╡ 46413082-5cb4-4862-a30f-0f26e23a8259
# use the bit array created above to return the values in the sequence that are
# divisible by 3
(1:9)[s3]    # the bit array is in []

# ╔═╡ ef90a885-5aaf-44d9-8e15-932f366c5f0a
md"""
It can also be used to simply select every 3rd element from any collection that has the same length as the bit array. 
"""

# ╔═╡ 9c3535a1-aa7c-4ac2-ba87-7fe57f318bd0
md"""
### Adjoints and Transposes 

There exists three different ways to flip a matrix across its diagonal for a matrix containing real numbers.
"""

# ╔═╡ 1ef232ba-fae2-4b7e-8cd3-7202d83205b1
MR = [[1 2]; [3 4]]

# ╔═╡ 87f04e26-6682-4fa6-8bd9-1fdff07ca06f
# transpose 
MR'

# ╔═╡ cabc9863-1fcb-405f-b901-dfb055e4e1a0
adjoint(MR)

# ╔═╡ 7d164d94-3c48-4628-955d-97d7668f8774
permutedims(MR)

# ╔═╡ 4b861aa7-7eb4-4908-a7fe-f7c1e4ecb88e
md"""
Honestly, the first way is the most convenient. Also this only works in the second case because the adjoint of this matrix happens to be its transpose. If we have different elements our matrix, the last two functions will give different results. 

In this section there are some other matrix related operations; however, I'm not entirely familiar with them and will skip over them. 

To take the complete conjugate of a number, use conj().
"""

# ╔═╡ 951b278f-e081-44b0-ae12-8f7959bed7c6
conj(2+2im)

# ╔═╡ b4028b42-3495-41cc-867c-3395623a32b1
md"""
### Matrix Multiplication 

Simply use the built-in * for matrix multiplication. You can also compute the inverse of a matrix using base Julia by raising it to -1.
"""

# ╔═╡ 06595bf3-96fc-4de5-9ab7-a6b484c98b79
MR * MR

# ╔═╡ 17694221-870a-4aa7-9489-42db54b88231
MR^-1

# ╔═╡ daed9362-450e-49f7-b580-810df4fb9922
md"""
For *serious* work with matrices, systems of linear equations, etc. use the *LinearAlgebra* package, which will be covered later. 
"""

# ╔═╡ 9edcf185-2084-47bb-9a4e-c04c3ce8875f
md"""
## Enumeration and Zipping 

Enumerating an array means to associate the elements of the array with integer indices. Zipping an array means to take two collections and join them element by element. These functions return iterators. 
"""

# ╔═╡ d5ac2ed5-3782-469e-9767-80d00fc2947f
# enumerate the elements in a 2x2 matrix
collect(enumerate([10 20; 30 40]))

# ╔═╡ ecb08ded-09a7-4ab9-9849-250acec2231b
md"""
Recall we have to use *collect()* since *enumerate()* returns an iterator. However, don't confuse iteration numbers with indices. 

### pairs()

This does the same thing as enumerate except that instead of creating indices using integers, it creates indices using key-value pairs. The keys can be acccess with the property notation *p.first* and the value using *p.second*.

### zip()

Takes any number of collections and returns an iterator into a collection of tuples that combines the elements of the collections 
"""

# ╔═╡ ed5b5f49-7998-4849-b81a-6c826614c561
# collections with same shape
zip([1 2; 3 4], ['a' 'b'; 'c' 'd']) |> collect

# ╔═╡ 00000000-0000-0000-0000-000000000001
PLUTO_PROJECT_TOML_CONTENTS = """
[deps]
"""

# ╔═╡ 00000000-0000-0000-0000-000000000002
PLUTO_MANIFEST_TOML_CONTENTS = """
# This file is machine-generated - editing it directly is not advised

julia_version = "1.8.3"
manifest_format = "2.0"
project_hash = "da39a3ee5e6b4b0d3255bfef95601890afd80709"

[deps]
"""

# ╔═╡ Cell order:
# ╟─2c2fd9f4-6d24-11ed-3117-23d7346a8f33
# ╠═cd53e3c6-5a08-40f6-a3a8-ae37f70f43af
# ╠═40dc108b-f8e8-41c3-9fbe-afa1137a5bba
# ╠═d2b0d0d1-5fce-4ed8-b922-d5c40595ebaf
# ╟─e8498f77-296b-4587-8cdd-7dac92c5a7af
# ╠═193d7648-fdf5-4254-8d70-34f32b6620b6
# ╟─85f8f1cc-004e-4f4c-bdbd-50dbeeb68b2e
# ╠═b043f043-92f5-4caf-b382-68cbee016731
# ╠═4e3851a1-83ef-4e83-aaa0-3ea76489ba19
# ╠═399a16b6-7cae-4d7d-8715-3e0d34c291ff
# ╠═fa9aa79a-9c9d-4bd0-9991-af5b72f5088d
# ╠═0a08e119-95ba-4b75-99f7-17af4fcb298e
# ╠═ba8a0fc3-795c-4465-a51e-5efaae00687d
# ╠═fe27b89d-40e2-47bb-88b2-2b14ff4790ae
# ╟─6b5516d0-e97c-4acd-a652-4d8732bc78f5
# ╟─bc0032ee-a126-41bd-9372-37816383b6ca
# ╠═1024a5dd-716d-453b-80b8-b2b00d324d42
# ╠═801e5484-eb2e-4a26-88d2-7142a3d0b4e7
# ╠═734bf1af-7a23-427d-a60d-c5556e52ca6a
# ╠═5b574b39-685a-4447-96cb-f7c4bc930743
# ╟─2861dd72-fcf8-4e02-a482-50c180a61166
# ╠═a53cd5d1-c7b4-4abf-bc07-59f18926c8f8
# ╠═7138bdba-2574-4195-bb5b-9d576b55a8b4
# ╟─17482ccc-3b7d-4e0d-a3a8-f82c8709014a
# ╠═8f617661-d7b0-4704-b05c-b9e6ff002c98
# ╠═1669072b-f907-44c3-b0e8-747e7e3b2933
# ╠═ad458e5b-b795-4e6f-a1a0-dfbc933efdad
# ╟─60218ddd-1cf2-4ddb-bfbe-92ae25cd556b
# ╠═1f3f9255-d98a-4fcc-b789-29064a3e98f2
# ╠═d6eca711-c152-4606-92dc-b62320cb7954
# ╠═9541ab93-12e7-4f11-b310-4246d962f23f
# ╠═7d408506-d311-4be5-893a-42a63baec349
# ╠═b119dbae-d64c-4c0e-884f-b2e55e30d387
# ╠═71ef4dc2-1cae-4afc-945a-379a79b70439
# ╠═3eeeb46c-5808-42d8-bd10-a9461050085d
# ╠═fbb5fbcc-b602-4404-a98a-84d0dbac92f0
# ╠═1be8dd97-8aa7-4145-8d35-adc373246dc0
# ╠═ba48907a-e0fb-468e-b8a4-fe8638f42bb7
# ╠═6f68f0dd-dde1-4bd3-8153-88d395495b3a
# ╠═6a944825-1594-40fb-ba2b-adde7159a560
# ╟─992daf44-151d-4325-bfcd-2cf34f84a89c
# ╠═b7d775e0-5dcb-4a14-b068-8e2d5c2c080a
# ╟─9e6ab062-6a0e-4dea-b406-5e6b1257f93e
# ╠═2fc33a9f-28f1-4e9a-88d7-a161a435cb00
# ╠═6f479153-fe99-4d53-9afa-d71add3e24f3
# ╠═902f03f1-c652-4dc0-adef-ca312216435b
# ╟─12efc098-5503-4a69-80ac-b0c1b1d1c2f0
# ╠═0211d068-72ec-4ca0-b118-55939fea2611
# ╟─5001c3ee-bdb2-460a-b4a1-6ad61cbe0f7e
# ╠═812c87cf-676d-4798-8107-be84ca7f4cd2
# ╠═db8143be-90b1-4b82-8481-1973c353ca09
# ╠═b3d521e5-51e7-4e1c-84e7-8362a5970bce
# ╠═6aa2649a-1093-4266-9f42-8fe576b00a05
# ╠═f00ccf5f-9d2c-43ae-bff0-d5b9094ef7c2
# ╠═03226d85-57ca-4ca3-9ab1-b6691e90b12b
# ╠═b14aca39-a3e1-486a-a238-5b682620c18b
# ╠═e04c93de-fdf2-44b3-8420-b792d1fe95f3
# ╠═1a266b38-d769-453d-8c0f-fe4101e2c892
# ╠═dc1bcc70-ec19-42a5-938c-7837e5d13911
# ╠═5dfc8e81-b90f-46bd-88ac-d0fcf2b7c1cc
# ╟─1dedd305-5f2d-4b52-9ae3-4b47f7d64214
# ╠═dac2ae13-bdca-402d-aa58-53fb25c7c383
# ╠═0351ff00-e1d5-4eca-9049-3f1919207fa1
# ╠═171b3c5b-eb59-40b6-a2c5-3eabbd71335c
# ╠═9a4f9f42-2328-4b25-90cb-c2047ed7b0c8
# ╟─1f035d70-ebd0-4c7a-b4ab-af7ce5e055ad
# ╠═1fa9d73f-2866-44a0-8256-4c592efe6998
# ╠═9468c128-fd0f-4439-b6b3-6644e8e838d2
# ╠═2d6fc98b-8585-4734-a6bd-aad91fac5015
# ╠═5d8755bc-9f71-4ca9-b39c-768cc7f42d19
# ╟─f5471a60-a439-4ee1-91c6-6746d84fc499
# ╠═a4f4353f-eb1e-41fb-878a-b0a37288e73e
# ╠═dffad748-ca3d-4fde-ad69-e788e7171125
# ╟─1d6d908f-7a2f-4511-93d3-d13a81937d2b
# ╠═8bdad294-0ddf-4ada-b5c9-bc897a598d12
# ╟─dcdc6fdb-e6d5-4c5c-aaea-3862456d04d4
# ╠═5efc93bd-1522-419b-9fb9-28deee71e206
# ╟─ec124550-e007-4ebf-b47e-44617d4e8b3b
# ╠═24e00439-638b-42d0-958c-89d4b3fb9819
# ╟─a2be4b47-9094-4cb1-b1c9-3d270cd77a65
# ╠═47dbec4d-afcf-4ebb-92bd-57f2ee41b769
# ╠═271d04ab-98c9-4807-b17c-c531d4a624f1
# ╟─63ed32e4-1823-4138-94ed-25235875af85
# ╠═2e6209e7-6484-4f8a-8f6b-429fde2c53d3
# ╠═1fd7d2a9-cc72-41f0-bacd-61f151a15b01
# ╠═c3802f33-0a5c-4394-b7d6-11f43b634731
# ╟─188e6f52-d694-4aee-8239-0a9d89f44570
# ╠═181299c9-8898-4b9a-ac41-213551edccb6
# ╠═46413082-5cb4-4862-a30f-0f26e23a8259
# ╟─ef90a885-5aaf-44d9-8e15-932f366c5f0a
# ╟─9c3535a1-aa7c-4ac2-ba87-7fe57f318bd0
# ╠═1ef232ba-fae2-4b7e-8cd3-7202d83205b1
# ╠═87f04e26-6682-4fa6-8bd9-1fdff07ca06f
# ╠═cabc9863-1fcb-405f-b901-dfb055e4e1a0
# ╠═7d164d94-3c48-4628-955d-97d7668f8774
# ╟─4b861aa7-7eb4-4908-a7fe-f7c1e4ecb88e
# ╠═951b278f-e081-44b0-ae12-8f7959bed7c6
# ╟─b4028b42-3495-41cc-867c-3395623a32b1
# ╠═06595bf3-96fc-4de5-9ab7-a6b484c98b79
# ╠═17694221-870a-4aa7-9489-42db54b88231
# ╟─daed9362-450e-49f7-b580-810df4fb9922
# ╟─9edcf185-2084-47bb-9a4e-c04c3ce8875f
# ╠═d5ac2ed5-3782-469e-9767-80d00fc2947f
# ╟─ecb08ded-09a7-4ab9-9849-250acec2231b
# ╠═ed5b5f49-7998-4849-b81a-6c826614c561
# ╟─00000000-0000-0000-0000-000000000001
# ╟─00000000-0000-0000-0000-000000000002
